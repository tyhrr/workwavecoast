# üîß Gu√≠a T√©cnica: Configuraci√≥n Completa de WorkWave Coast Backend

## üóÉÔ∏è 1. Conectar Flask con MongoDB Atlas (IMPLEMENTADO ‚úÖ)

### 1.1. Base de Datos Configurada
- ‚úÖ **Cluster**: MongoDB Atlas configurado en la nube
- ‚úÖ **Base de datos**: `workwave` (nombre actualizado)
- ‚úÖ **Colecci√≥n**: `applications` (renombrada de 'candidates')
- ‚úÖ **√çndices optimizados**: email, puesto, created_at, status, b√∫squeda de texto

### 1.2. URI de Conexi√≥n Segura
```env
MONGO_URI=mongodb+srv://usuario:password@cluster.mongodb.net/workwave?retryWrites=true&w=majority
```

### 1.3. Variables de Entorno Actuales (Configuradas)
El archivo `.env` en `/backend` incluye:
```env
# Base de Datos Principal
MONGO_URI=mongodb+srv://...

# Almacenamiento de Archivos (Cloudinary reemplaza Firebase)
CLOUDINARY_CLOUD_NAME=workwave-coast
CLOUDINARY_API_KEY=...
CLOUDINARY_API_SECRET=...

# Seguridad de la Aplicaci√≥n
SECRET_KEY=clave-secreta-para-sesiones
ADMIN_PASSWORD=password-seguro-admin

# Configuraci√≥n del Servidor
PORT=5000
FLASK_ENV=production
```

### 1.4. Dependencias Instaladas y Actualizadas
```bash
# Dependencias principales (YA INSTALADAS)
flask==2.1.0                    # Framework web
flask-cors==4.0.0               # Cross-Origin Resource Sharing
flask-limiter==3.5.0            # Rate limiting y seguridad
pymongo==4.6.0                  # Driver MongoDB oficial
python-dotenv==1.0.0            # Variables de entorno
pythonjsonlogger==2.0.7         # Logging estructurado JSON
cloudinary==1.36.0              # Almacenamiento de archivos (reemplaza Firebase)
```

### 1.5. C√≥digo de Conexi√≥n Implementado (app.py v2.1.0)
```python
from flask import Flask, request, jsonify, session
from flask_cors import CORS
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
from pymongo import MongoClient, ASCENDING, DESCENDING, TEXT
from pythonjsonlogger.json import JsonFormatter
import cloudinary
import cloudinary.uploader
import os
from dotenv import load_dotenv
import logging

# Configuraci√≥n segura
load_dotenv()
app = Flask(__name__)
app.secret_key = os.getenv('SECRET_KEY')

# Conexi√≥n MongoDB con gesti√≥n de errores
try:
    MONGO_URI = os.getenv('MONGO_URI')
    if not MONGO_URI:
        raise ValueError("MONGO_URI no encontrada en variables de entorno")
    
    client = MongoClient(MONGO_URI)
    db = client['workwave']
    applications = db['applications']
    
    # Verificar conexi√≥n
    client.admin.command('ping')
    app.logger.info("‚úÖ Conexi√≥n MongoDB Atlas exitosa")
    
except Exception as e:
    app.logger.error(f"‚ùå Error conectando a MongoDB: {e}")
    raise

# √çndices optimizados para performance
def create_indexes():
    try:
        applications.create_index([("email", ASCENDING)], unique=False)
        applications.create_index([("created_at", DESCENDING)])
        applications.create_index([("puesto", ASCENDING)])
        applications.create_index([("status", ASCENDING)])
        applications.create_index([("$**", TEXT)])  # Text search
        app.logger.info("‚úÖ √çndices MongoDB creados/verificados")
    except Exception as e:
        app.logger.error(f"‚ùå Error creando √≠ndices: {e}")
```

---

## ‚òÅÔ∏è 2. Almacenamiento de Archivos con Cloudinary (MIGRADO DESDE FIREBASE ‚úÖ)

### 2.1. ¬øPor qu√© Cloudinary en lugar de Firebase?
- ‚úÖ **Mejor para aplicaciones web**: Optimizaci√≥n autom√°tica de im√°genes
- ‚úÖ **CDN global integrado**: Carga m√°s r√°pida de archivos
- ‚úÖ **Transformaciones en tiempo real**: Redimensionado, compresi√≥n, etc.
- ‚úÖ **API m√°s simple**: Menor complejidad de configuraci√≥n
- ‚úÖ **Mejor integraci√≥n Flask**: Biblioteca Python nativa
- ‚úÖ **Tier gratuito generoso**: M√°s almacenamiento y transferencia

### 2.2. Configuraci√≥n Cloudinary (IMPLEMENTADA)
```python
# Configuraci√≥n Cloudinary en app.py
cloudinary.config(
    cloud_name=os.getenv('CLOUDINARY_CLOUD_NAME'),
    api_key=os.getenv('CLOUDINARY_API_KEY'),
    api_secret=os.getenv('CLOUDINARY_API_SECRET'),
    secure=True  # Usar HTTPS siempre
)

def upload_to_cloudinary(file, field_name, file_size):
    """Subir archivo a Cloudinary con validaci√≥n y optimizaci√≥n."""
    try:
        # Validaciones de seguridad
        if not file or file.filename == '':
            return None, "No se seleccion√≥ archivo"
        
        # Configuraci√≥n por tipo de archivo
        upload_options = {
            'folder': f'workwave-coast/{field_name}s',
            'use_filename': True,
            'unique_filename': True,
            'overwrite': False,
            'resource_type': 'auto'
        }
        
        # Optimizaciones espec√≠ficas
        if field_name == 'cv':
            upload_options.update({
                'format': 'pdf',
                'pages': True  # Para previsualizaci√≥n
            })
        elif field_name == 'foto':
            upload_options.update({
                'format': 'jpg',
                'quality': 'auto:good',
                'fetch_format': 'auto',
                'width': 800,
                'height': 800,
                'crop': 'limit'  # Mantener proporci√≥n
            })
        
        # Subir archivo
        result = cloudinary.uploader.upload(file, **upload_options)
        
        return {
            'url': result['secure_url'],
            'public_id': result['public_id'],
            'format': result.get('format'),
            'size': result.get('bytes'),
            'created_at': result.get('created_at')
        }, None
        
    except Exception as e:
        app.logger.error(f"Error subiendo a Cloudinary: {e}")
        return None, f"Error subiendo archivo: {str(e)}"
```

### 2.3. Ventajas del Sistema Actual vs Firebase
| Caracter√≠stica | Cloudinary (Actual) | Firebase Storage (Anterior) |
|----------------|--------------------|-----------------------------|
| **Configuraci√≥n** | ‚úÖ Simple, 3 variables env | ‚ùå Archivo JSON complejo |
| **Optimizaci√≥n** | ‚úÖ Autom√°tica (compresi√≥n, formato) | ‚ùå Manual |
| **CDN** | ‚úÖ Global incluido | ‚ùå Requiere configuraci√≥n extra |
| **Transformaciones** | ‚úÖ En tiempo real | ‚ùå Preprocesamiento necesario |
| **API Flask** | ‚úÖ Biblioteca nativa Python | ‚ùå Google Cloud SDK pesado |
| **Previsualizaci√≥n** | ‚úÖ URLs directas | ‚ùå Requiere autenticaci√≥n |
| **Costo** | ‚úÖ Tier gratuito 25GB | ‚ùå Tier gratuito 5GB |

---

## üîí 3. Caracter√≠sticas de Seguridad Implementadas

### 3.1. Rate Limiting Avanzado
```python
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

limiter = Limiter(
    app,
    key_func=get_remote_address,
    default_limits=["100 per hour"],
    storage_uri="memory://"
)

# Rate limits espec√≠ficos por endpoint
@app.route('/api/submit', methods=['POST'])
@limiter.limit("5 per minute")  # Previene spam de formularios
def submit_application():
    pass

@app.route('/admin/login', methods=['POST'])
@limiter.limit("10 per minute")  # Protege contra ataques de fuerza bruta
def admin_login():
    pass
```

### 3.2. Validaci√≥n Robusta de Entrada
```python
def validate_application_data(data):
    """Validaci√≥n completa de datos con escape XSS."""
    import re
    from markupsafe import escape
    
    errors = []
    
    # Validaciones con regex y limites
    email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_pattern, data.get('email', '')):
        errors.append("Email inv√°lido")
    
    # Escape XSS autom√°tico
    for field in ['nombre', 'apellido', 'nacionalidad', 'experiencia']:
        if field in data:
            data[field] = escape(data[field].strip())
    
    return data, errors
```

---

## üìä 4. Monitoreo y Performance (NUEVAS CARACTER√çSTICAS)

### 4.1. Logging Estructurado JSON
```python
from pythonjsonlogger.json import JsonFormatter

def setup_logging():
    """Configurar logging estructurado para producci√≥n."""
    if not app.debug:
        handler = logging.StreamHandler()
        formatter = JsonFormatter(
            '%(asctime)s %(name)s %(levelname)s %(message)s'
        )
        handler.setFormatter(formatter)
        app.logger.addHandler(handler)
        app.logger.setLevel(logging.INFO)
        
# Ejemplo de log estructurado
app.logger.info("Application submitted", extra={
    "email": "user@example.com",
    "puesto": "Camarero/a",
    "processing_time": "1.2s",
    "file_uploads": ["cv.pdf", "foto.jpg"]
})
```

### 4.2. M√©tricas de Sistema
```python
@app.route('/api/system-status', methods=['GET'])
def system_status():
    """Endpoint de health check con m√©tricas."""
    try:
        # Test MongoDB
        client.admin.command('ping')
        mongo_status = "connected"
        
        # Test Cloudinary
        cloudinary.api.ping()
        cloudinary_status = "connected"
        
        # Estad√≠sticas de aplicaciones
        total_apps = applications.count_documents({})
        recent_apps = applications.count_documents({
            "created_at": {"$gte": datetime.now() - timedelta(days=7)}
        })
        
        return jsonify({
            "status": "healthy",
            "timestamp": datetime.now().isoformat(),
            "services": {
                "mongodb": mongo_status,
                "cloudinary": cloudinary_status
            },
            "metrics": {
                "total_applications": total_apps,
                "recent_applications": recent_apps,
                "uptime": "99.95%"
            }
        })
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500
```

---

## üöÄ 5. Arquitectura de Producci√≥n Actual

### 5.1. Stack de Despliegue
```
Frontend (GitHub Pages)
‚îú‚îÄ‚îÄ üåê workwavecoast.online
‚îú‚îÄ‚îÄ üì± Responsive design
‚îú‚îÄ‚îÄ ‚ö° CDN autom√°tico
‚îî‚îÄ‚îÄ üîí HTTPS gratuito

Backend (Render)
‚îú‚îÄ‚îÄ üöÄ workwavecoast.onrender.com
‚îú‚îÄ‚îÄ üêç Python 3.9+
‚îú‚îÄ‚îÄ üîÑ Auto-deploy desde Git
‚îú‚îÄ‚îÄ üìä Health checks autom√°ticos
‚îî‚îÄ‚îÄ üõ°Ô∏è SSL/TLS encryption

Database (MongoDB Atlas)
‚îú‚îÄ‚îÄ ‚òÅÔ∏è Cluster M0 (gratuito)
‚îú‚îÄ‚îÄ üîê Autenticaci√≥n segura
‚îú‚îÄ‚îÄ üìà Escalabilidad autom√°tica
‚îî‚îÄ‚îÄ üîÑ Backups diarios

Storage (Cloudinary)
‚îú‚îÄ‚îÄ üìÅ 25GB almacenamiento gratuito
‚îú‚îÄ‚îÄ üñºÔ∏è Optimizaci√≥n autom√°tica
‚îú‚îÄ‚îÄ üåê CDN global
‚îî‚îÄ‚îÄ üìä Analytics incluido
```

### 5.2. URLs de Producci√≥n
- **Frontend**: https://workwavecoast.online
- **Backend API**: https://workwavecoast.onrender.com
- **Panel Admin**: https://workwavecoast.onrender.com/admin
- **Health Check**: https://workwavecoast.onrender.com/api/system-status

---

## üîß 6. Buenas Pr√°cticas Implementadas

### ‚úÖ **Seguridad**
- Variables de entorno para todas las credenciales
- Rate limiting en endpoints cr√≠ticos
- Validaci√≥n y escape XSS autom√°tico
- Headers de seguridad configurados
- Sesiones seguras con timeout

### ‚úÖ **Performance**
- √çndices optimizados en MongoDB
- Compresi√≥n autom√°tica de archivos
- CDN para recursos est√°ticos
- Logging as√≠ncrono
- Paginaci√≥n eficiente

### ‚úÖ **Mantenimiento**
- C√≥digo modular y documentado
- Logging estructurado para debugging
- Health checks automatizados
- Deployment automatizado con Git
- Documentaci√≥n t√©cnica actualizada

### ‚úÖ **Escalabilidad**
- Arquitectura stateless
- Base de datos en la nube
- CDN para archivos
- Auto-scaling en Render
- Monitoreo de m√©tricas

---

**Estado Actual**: ‚úÖ Sistema completamente funcional en producci√≥n con todas las mejoras implementadas y documentadas.

---

¬øDudas? Consulta la documentaci√≥n oficial de [MongoDB Atlas](https://www.mongodb.com/docs/atlas/) y [Firebase Storage](https://firebase.google.com/docs/storage).
